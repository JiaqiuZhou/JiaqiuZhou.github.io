<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiaqiuzhou.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"enable":false,"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="主要介绍关于unix操作系统的基本概念">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux操作系统详解">
<meta property="og:url" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/index.html">
<meta property="og:site_name" content="Ball&#39;s blog">
<meta property="og:description" content="主要介绍关于unix操作系统的基本概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/Computer.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/Computer_component.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/system_arch.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/kernel.jpg">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/system_call.jpg">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/process_state.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/File_system.jpg">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/Linux_ls.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/process_flow_chart.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/process_exit.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/memory_space.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/process.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/processs_compare_thread.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/pthread_share.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/process_communication.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/pipe_communication.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/message_queue.png">
<meta property="og:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/Signal.png">
<meta property="article:published_time" content="2020-08-20T01:57:21.000Z">
<meta property="article:modified_time" content="2020-11-07T14:21:04.035Z">
<meta property="article:author" content="Ball">
<meta property="article:tag" content="Software-System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/Computer.png">

<link rel="canonical" href="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux操作系统详解 | Ball's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ball's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Any way, be happy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/qiu.jpeg">
      <meta itemprop="name" content="Ball">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ball's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux操作系统详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-20 09:57:21" itemprop="dateCreated datePublished" datetime="2020-08-20T09:57:21+08:00">2020-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-07 22:21:04" itemprop="dateModified" datetime="2020-11-07T22:21:04+08:00">2020-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software/" itemprop="url" rel="index"><span itemprop="name">Software</span></a>
                </span>
            </span>

          
            <span id="/2020/08/20/Software/system/operating-system/" class="post-meta-item leancloud_visitors" data-flag-title="Linux操作系统详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/08/20/Software/system/operating-system/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/08/20/Software/system/operating-system/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>主要介绍关于unix操作系统的基本概念</p>
<a id="more"></a>
<h2 id="1-Computer"><a href="#1-Computer" class="headerlink" title="1. Computer"></a>1. Computer</h2><h3 id="1-1-What-is-a-computer"><a href="#1-1-What-is-a-computer" class="headerlink" title="1.1 What is a computer?"></a>1.1 What is a computer?</h3><ul>
<li><p>简单的来讲可以简化成一个<strong>输入和输出的模型</strong>，如下所示</p>
<p><img src="/2020/08/20/Software/system/operating-system/Computer.png" alt="Computer"></p>
</li>
<li><p>从组成计算机的基本单元出发，由以下单元组成，如下所示</p>
<p><img src="/2020/08/20/Software/system/operating-system/Computer_component.png" alt="Computer_component"></p>
<ul>
<li><strong>Case:</strong> 主机，装东西的地方</li>
<li><strong>Power Supply:</strong> 电源，经常需要AC Adapter进行</li>
<li><strong>Mother Board:</strong> 主板，输入输出控制</li>
<li><strong>CPU:</strong> 中央计算单元</li>
<li><strong>RAM:</strong> 内存，加载数据到RAM中，以便快速与CPU进行交互</li>
<li><strong>Hard Drive:</strong> 硬盘，存储大容量数据</li>
<li><strong>Graphics Card:</strong> 图形处理单元</li>
</ul>
</li>
</ul>
<h3 id="1-2-What-is-a-computer-program"><a href="#1-2-What-is-a-computer-program" class="headerlink" title="1.2 What is a computer program?"></a>1.2 What is a computer program?</h3><ul>
<li><strong>所见:</strong>常规理解来看，程序就是软件，就是游戏，就是各种编程</li>
<li><strong>所不见:</strong>负责我们键盘的输入转化为显示屏的显示，都是由计算机内部程序所负责的</li>
</ul>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><h3 id="2-1-发展历史"><a href="#2-1-发展历史" class="headerlink" title="2.1 发展历史"></a>2.1 发展历史</h3><ul>
<li><strong>Multics:</strong> 第一个分时操作系统，支持300位以上的用户联机使用</li>
<li><strong>UNIX:</strong> 源于Multics系统，做了大幅度简化，发明了<strong>C语言</strong>来进行开发，论文<strong>“The UNIX Time Sharing System”</strong>,由于开源后更多复用，因此设计了重要的<strong>UNIX标准</strong>包含<strong>ANSI C(C语言标准)</strong>、<strong>IEEE POSIX(应用程序接口)</strong>等</li>
<li><strong>GNU计划:</strong> 由于UNIX的逐渐商业化，Stallman发起了GNU(Not unix计划，目标是创建一个完全自由的<strong>类UNIX操作系统</strong></li>
<li><strong>Minix系统:</strong> UNIX规定不能对学生提供源码，Andrew Stuart Tanenbaum 编写了兼容于UNIX的Minix系统，用于教学</li>
<li><strong>Linux系统:</strong> 受到Minix系统的影响，基于386机器，Linus Torvalds开发了linux系统，加入了大部分自由的软件。遵循ANSI C的标准</li>
</ul>
<h3 id="2-2-linux系统的整体思想"><a href="#2-2-linux系统的整体思想" class="headerlink" title="2.2 linux系统的整体思想"></a>2.2 linux系统的整体思想</h3><h4 id="2-2-1-Everything-is-a-process—if-it’s-not-a-process-it’s-a-file"><a href="#2-2-1-Everything-is-a-process—if-it’s-not-a-process-it’s-a-file" class="headerlink" title="2.2.1 Everything is a process—if it’s not a process, it’s a file"></a>2.2.1 Everything is a process—if it’s not a process, it’s a file</h4><ul>
<li><strong>Process:</strong> program; 默认有三个文件会产生，Standard input(stdin,fd 0),Standard output(stdout, fd 1); Standard error(std err,fd 2)</li>
<li><strong>File:</strong> 目录, 设备等等都是一个文件</li>
<li><strong>Virtual Filesystem Switch(VFS):</strong> 把所有需要处理东西转换为文件读写，如鼠标读写转换为I/O文件读写，VFS编写好了驱动程序，通过设备文件来修改驱动设备</li>
</ul>
<h4 id="2-2-2-One-tool-to-do-one-task"><a href="#2-2-2-One-tool-to-do-one-task" class="headerlink" title="2.2.2 One tool to do one task"></a>2.2.2 One tool to do one task</h4><ul>
<li><strong>思想:</strong> 每个工具只做好一件事情</li>
<li><strong>Example:</strong> df 是查看目录文件，sort是排序，每个工具只做一件事情，如果要对查看的文件排序，则需要结合两个工具</li>
</ul>
<h4 id="2-2-3-Three-standard-I-O-channels"><a href="#2-2-3-Three-standard-I-O-channels" class="headerlink" title="2.2.3 Three standard I/O channels"></a>2.2.3 Three standard I/O channels</h4><ul>
<li><strong>文件描述符:</strong> 每个process产生以后都会分配file descriptor(文件描述符),比如说stdin对应0，stdout对应1</li>
<li><strong>重定向操作符:</strong> &gt;把输出结果重定向到某个位置，</li>
<li><strong>Example:</strong> ls &gt; a.txt;则会把ls的结果放到文件a中</li>
</ul>
<h4 id="2-2-4-Combine-tools-seamlessly"><a href="#2-2-4-Combine-tools-seamlessly" class="headerlink" title="2.2.4 Combine tools seamlessly"></a>2.2.4 Combine tools seamlessly</h4><ul>
<li><strong>传输机制:</strong> 通过每个工具之间采用IPC mechanism called pipe</li>
<li><strong>Example:</strong> task A | task B —&gt; 把task A 的输出给到task B</li>
</ul>
<h4 id="2-2-5-Plain-text-preferred"><a href="#2-2-5-Plain-text-preferred" class="headerlink" title="2.2.5 Plain text preferred"></a>2.2.5 Plain text preferred</h4><ul>
<li><strong>思想:</strong> 文本优先，LINUX都是通过文本的形式实现，服务的配置等等</li>
</ul>
<h4 id="2-2-6-CLI-not-GUI"><a href="#2-2-6-CLI-not-GUI" class="headerlink" title="2.2.6 CLI, not GUI"></a>2.2.6 CLI, not GUI</h4><ul>
<li><strong>思想:</strong> 用命令行，而不是界面</li>
</ul>
<h4 id="2-2-7-Modular-desigend-to-be-repurposed-by-others"><a href="#2-2-7-Modular-desigend-to-be-repurposed-by-others" class="headerlink" title="2.2.7 Modular,desigend to be repurposed by others"></a>2.2.7 Modular,desigend to be repurposed by others</h4><ul>
<li><strong>思想:</strong> 模块化思想，方便于扩充</li>
</ul>
<h4 id="2-2-8-Provide-mechanisms-not-policies"><a href="#2-2-8-Provide-mechanisms-not-policies" class="headerlink" title="2.2.8 Provide mechanisms, not policies"></a>2.2.8 Provide mechanisms, not policies</h4><ul>
<li><strong>思想:</strong> 把基本的东西都实现好了，然后怎么用就看user怎么调用</li>
</ul>
<h3 id="2-3-系统架构"><a href="#2-3-系统架构" class="headerlink" title="2.3 系统架构"></a>2.3 系统架构</h3><ul>
<li><p><strong>操作系统</strong>是架设于计算机硬件之上的，管理计算机硬件与软件资源的计算机程序，应包含以下几个部分:</p>
<ul>
<li><strong>Bootloader:</strong> 管理设备的启动程序</li>
<li><strong>Kernel:</strong>系统核心，管理CPU，内存和外围设备</li>
<li><strong>Daemons:</strong> 守护进程</li>
<li><strong>Networking:</strong> 系统之间的信息交流</li>
<li><strong>Shell:</strong> 允许进入文本界面来输入命令操纵设备</li>
<li><strong>Graphical Server:</strong> 图形界面显示系统</li>
<li><strong>Desktop Environment:</strong> 人机交互界面</li>
<li><strong>Applications:</strong> 软件</li>
</ul>
</li>
<li><p><strong>基本架构</strong>图如下所示:</p>
<p><img src="/2020/08/20/Software/system/operating-system/system_arch.png" alt="system_arch"></p>
<p><img src="/2020/08/20/Software/system/operating-system/kernel.jpg" alt="kernel"></p>
</li>
</ul>
<ul>
<li><strong>Kernel space and user space:</strong> kernel space是具有对设备的绝对控制权限，提供系统服务和内存控制；user space是用户对系统的应用，只能通过kernel servie调用来控制。</li>
</ul>
<h3 id="2-4-内核的功能"><a href="#2-4-内核的功能" class="headerlink" title="2.4 内核的功能"></a>2.4 内核的功能</h3><ul>
<li><p><strong>内存管理功能</strong></p>
<ul>
<li><strong>内存分配调用:</strong> 静态分配方式、动态分配方式</li>
<li><strong>内存保护:</strong> 确保每个程序在自己的内存空间运行、互不干扰</li>
<li><strong>地址映射:</strong> 实现程序的逻辑地址与存储器的物理地址映射</li>
<li><strong>内存扩充:</strong> 逻辑扩充物理内存即调入与置换功能</li>
</ul>
</li>
<li><p><strong>进程管理功能</strong></p>
<ul>
<li><strong>进程控制:</strong> 包含进程创建、进程撤销、进程阻塞、进程唤醒</li>
<li><strong>进程协调:</strong> 进程互斥与进程同步</li>
<li><strong>进程通信:</strong> 同一机器不同进程，不同机器进程通信</li>
<li><strong>进程调度:</strong> 按照一定规则对多道程序进行调度</li>
</ul>
</li>
<li><p><strong>文件管理功能</strong></p>
<ul>
<li><strong>文件存储空间的管理:</strong> 设置相应数据结构，记录文件存储空间</li>
<li><strong>目录管理:</strong> 建立一定结构的目录结构，同时要求快速的目录查询</li>
<li><strong>文件的读、写管理和存取控制:</strong> 有效存取控制功能，防止非法访问，读写操作等</li>
</ul>
</li>
<li><p><strong>设备管理功能</strong></p>
<ul>
<li><strong>缓冲管理:</strong> 管理各种类型缓冲区，提高CPU和I/O设备的利用率</li>
<li><strong>设备分配:</strong> 根据I/O请求，分配设备</li>
<li><strong>设备处理:</strong> 设备驱动程序，实现CPU和设备的通信</li>
<li><strong>设备独立性和虚拟设备:</strong> 保证用户程序独立于物理设备，多个进程并发地共享同一个设备</li>
</ul>
</li>
</ul>
<h3 id="2-5-操作系统用户接口"><a href="#2-5-操作系统用户接口" class="headerlink" title="2.5 操作系统用户接口"></a>2.5 操作系统用户接口</h3><ul>
<li><strong>命令接口:</strong> 以命令形式呈现在用户面前，方便用户直接或间接控制自己的作业</li>
<li><strong>程序接口:</strong> 为应用程序使用系统功能而设置，有一系列系统调用组成,每一个系统调用都是一个能完成特定功能的子程序</li>
<li><strong>图形接口:</strong> 将各种应用程序和文件直观地表示出来</li>
</ul>
<h3 id="2-6-系统调用"><a href="#2-6-系统调用" class="headerlink" title="2.6 系统调用"></a>2.6 系统调用</h3><ul>
<li><p><strong>系统调用:</strong> 是内核提供的程序接口，应用程序与硬件设备的中间层，提供了系统服务和硬件抽象能力</p>
</li>
<li><p><strong>文件操作类:</strong> 打开、修改文件等</p>
</li>
<li><p><strong>进程控制类:</strong> 创建进程、设置进程属性等</p>
</li>
<li><p><strong>通信类:</strong> 通信连接、发送、接收消息等</p>
</li>
<li><p><strong>设备管理类:</strong> 打开、关闭和操作设备</p>
</li>
<li><p><strong>信息维护类:</strong> 想用户程序传送当前时间、日期等</p>
</li>
<li><p><strong>内核系统调用与C库函数的关系:</strong> 几个不同函数可能对应一个系统调用，C库函数相当于对系统调用的一种封装形式</p>
</li>
<li><p><strong>应用程序对内核的调用:</strong> 内核系统调用遵循POSIX写成C库的形式，应用程序通过C库来对内核进行系统调用</p>
</li>
<li><p><strong>Example:</strong> malloc函数和free函数都是通过sbrk系统调用来管理堆栈空间</p>
<p><img src="/2020/08/20/Software/system/operating-system/system_call.jpg" alt="system_call"></p>
</li>
</ul>
<h3 id="2-7-常用UNIX-Linux命令—shell应用程序"><a href="#2-7-常用UNIX-Linux命令—shell应用程序" class="headerlink" title="2.7 常用UNIX/Linux命令—shell应用程序"></a>2.7 常用UNIX/Linux命令—shell应用程序</h3><h4 id="2-7-1-文件目录类命令"><a href="#2-7-1-文件目录类命令" class="headerlink" title="2.7.1 文件目录类命令"></a>2.7.1 文件目录类命令</h4><ul>
<li><strong>浏览目录命令:</strong> ls pwd</li>
<li><strong>目录操作命令:</strong> cd mkdir rmdir</li>
<li><strong>浏览文件命令:</strong> cat more less head tail </li>
<li><strong>文件操作命令:</strong> cp rm mv find grep tar</li>
</ul>
<h4 id="2-7-2-进程控制类命令"><a href="#2-7-2-进程控制类命令" class="headerlink" title="2.7.2 进程控制类命令"></a>2.7.2 进程控制类命令</h4><ul>
<li><p><strong>进程概念:</strong> 程序是一段可执行文件，进程则是将程序装载到内存后分配一定资源，成为进程，进程的状态如下:</p>
<p><img src="/2020/08/20/Software/system/operating-system/process_state.png" alt="process_state"></p>
</li>
<li><p><strong>查看系统进程:</strong> ps top</p>
</li>
<li><p><strong>控制系统进程:</strong> kill killall nice renice</p>
</li>
<li><p><strong>进程后台运行:</strong> &amp;</p>
</li>
<li><p><strong>进程挂起和恢复:</strong> 挂起(ctrl+z) 终止(Ctrl+c) 恢复到前台(fg) 恢复到后台(bg) 查看被挂起的进程(jobs)</p>
</li>
</ul>
<h4 id="2-7-3-用户及权限管理类命令"><a href="#2-7-3-用户及权限管理类命令" class="headerlink" title="2.7.3 用户及权限管理类命令"></a>2.7.3 用户及权限管理类命令</h4><ul>
<li><strong>用户概念:</strong> 超级用户，系统用户和普通用户,用户信息位于/etc下</li>
<li><strong>用户管理类:</strong> useradd usermod passwd userdel su id whoami w finger</li>
<li><strong>用户组管理类:</strong> groupadd groupmod groupedel</li>
<li><strong>文件权限管理类:</strong> chmod chown chgrp</li>
</ul>
<h3 id="2-8-程序编译调试方法"><a href="#2-8-程序编译调试方法" class="headerlink" title="2.8 程序编译调试方法"></a>2.8 程序编译调试方法</h3><h4 id="2-8-1-执行流程"><a href="#2-8-1-执行流程" class="headerlink" title="2.8.1 执行流程"></a>2.8.1 执行流程</h4><ul>
<li><strong>编译流程:</strong> 源文件—&gt;预处理—&gt;编译—&gt;汇编—&gt;链接—&gt;可执行</li>
<li><strong>静态链接与动态链接:</strong> 动态链接也就是程序执行需要额外链接文件，静态链接也就是程序直接执行，不需要额外文件；<ul>
<li><strong>更改一个子模块:</strong> 静态链接需要重新整个编译，动态链接之需要更改小模块文件的链接</li>
</ul>
</li>
</ul>
<h4 id="2-8-2-编译器GCC-GNU-Compiler-Collection"><a href="#2-8-2-编译器GCC-GNU-Compiler-Collection" class="headerlink" title="2.8.2 编译器GCC(GNU Compiler Collection)"></a>2.8.2 编译器GCC(GNU Compiler Collection)</h4><ul>
<li><p><strong>主要包括:</strong> cpp(预处理器)、gcc(c编译器)、g++(c++编译器)、binutils等二进制工具.as(汇编器)，ld(链接器)</p>
</li>
<li><p><strong>-D:</strong> 宏定义; <strong>-l:</strong> 额外的头文件搜索路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c increase.c </span><br><span class="line">gcc increase.c -o increase.o</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态库编译:</strong> 动态链接库的名字必须以lib开头, .so结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libinc.so increase.c</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反编译工具:</strong> objdump —source <binary-executable-pathname></binary-executable-pathname></p>
</li>
</ul>
<h4 id="2-8-3-gdb程序调试工具"><a href="#2-8-3-gdb程序调试工具" class="headerlink" title="2.8.3 gdb程序调试工具"></a>2.8.3 gdb程序调试工具</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb &lt;program&gt;</span><br><span class="line">gdb -s &lt;function&gt; <span class="comment">//单歩调试进入函数</span></span><br></pre></td></tr></table></figure>
<h3 id="2-9-main-函数"><a href="#2-9-main-函数" class="headerlink" title="2.9 main 函数"></a>2.9 main 函数</h3><ul>
<li>C程序总是从main开始执行，argc表示命令行参数的数目，argv是指向参数的各个指针所构成的数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-UNIX-Linux文件系统"><a href="#3-UNIX-Linux文件系统" class="headerlink" title="3. UNIX/Linux文件系统"></a>3. UNIX/Linux文件系统</h2><h3 id="3-1-文件系统基本概念"><a href="#3-1-文件系统基本概念" class="headerlink" title="3.1 文件系统基本概念"></a>3.1 文件系统基本概念</h3><ul>
<li><strong>一切皆是文件:</strong> 允许不同文件系统共存,如ext2,ext3,ext4,xfs,btrfs等，不同类型的文件系统可以通过相同的API对其操作</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件系统</th>
<th style="text-align:center">适用场景</th>
<th style="text-align:center">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ext2</td>
<td style="text-align:center">U盘</td>
<td style="text-align:center">不写日志，对安全性要求不高，兼容FAT</td>
</tr>
<tr>
<td style="text-align:center">ext3</td>
<td style="text-align:center">稳定性要求高</td>
<td style="text-align:center">ext4稳定性不高</td>
</tr>
<tr>
<td style="text-align:center">ext4</td>
<td style="text-align:center">小文件较少</td>
<td style="text-align:center">不支持inode动态分配</td>
</tr>
<tr>
<td style="text-align:center">xfs</td>
<td style="text-align:center">小文件多</td>
<td style="text-align:center">支持inode动态分配</td>
</tr>
<tr>
<td style="text-align:center">btrfs</td>
<td style="text-align:center">无频繁写</td>
<td style="text-align:center">功能众多</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>文件系统基本架构:</strong></p>
<p><img src="/2020/08/20/Software/system/operating-system/File_system.jpg" alt="File_system"></p>
</li>
<li><p><strong>虚拟文件系统(VFS):</strong> 定义了所有文件系统都支持的抽象接口和数据结构，实际文件系统去实现VFS的抽象借口和数据结构，隐藏了具体细节</p>
<ul>
<li><strong>VFS-超级块:</strong> <strong>文件系统</strong>的描述，用于<strong>存储文件系统的控制信息</strong>的数据结构。描述文件系统的状态、类型、大小等；每个具体的文件系统都会有各自的超级块，所有超级块以双向环形链表形式链接</li>
<li><strong>VFS-索引节点(inode):</strong> <strong>文件物理属性</strong>的描述，存储文件基本信息的数据结构，包含大小、拥有者、创建时间、磁盘位置等信息，对文件是唯一的，随文件的存在而存在</li>
<li><strong>VFS-目录项对象dentry:</strong> <strong>文件逻辑属性的描述</strong>，目录被用来容纳文件，也就是说在磁盘上没有对应映像，而是逻辑上规定</li>
<li><strong>VFS-文件对象file:</strong> 进程是通过文件描述符来访问文件的，每个进程用一个files_struct结构来记录文件描述符的使用情况，一组在逻辑上具有完整意义的信息项的系列</li>
</ul>
</li>
<li><p><strong>文件系统的注册和注销:</strong> </p>
<ul>
<li><strong>VFS初始函数注册:</strong> 填写文件注册表file_system_type数据结构</li>
<li><strong>注销结构:</strong> 删除一个file_system_type结构,需调用unregister_filesystem()函数</li>
</ul>
</li>
<li><p><strong>文件系统的安装:</strong></p>
<ul>
<li><p><strong>三种信息:</strong> 文件系统的名称、包含文件系统的物理块设备、文件系统在已有文件系统中的安装点</p>
</li>
<li><p><strong>Example:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount 光驱文件系统名称 物理块设备 安装到的目录</span></span><br><span class="line">mount -t iso9660 /dev/hdc /mnt/cdrom</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>文件系统的卸载:</strong> VFS超级块被释放，代码为sys_umount()函数</p>
</li>
</ul>
<h3 id="3-2-文件系统的IO操作"><a href="#3-2-文件系统的IO操作" class="headerlink" title="3.2 文件系统的IO操作"></a>3.2 文件系统的IO操作</h3><ul>
<li><p><strong>linux系统调用:</strong> 应用程序—&gt;用户编程接口API—&gt;系统调用(内核空间)</p>
</li>
<li><p><strong>文件描述符:</strong> 作为特定文件的<strong>索引值</strong>。当打开一个现存文件或创建一个新文件时，内核就向进程返回一个<strong>文件描述符</strong>；当需要读写文件时，也需要把文件描述符作为参数传递给函数</p>
<ul>
<li><strong>0,1,2:</strong> shell将文件描述符<strong>0定义为标准输入</strong>也就是<strong>STDIN_FIENO</strong>，<strong>1定义为标准输出</strong>也就是<strong>STDOUT_FILENO</strong>，<strong>2定义为标准错误</strong>也就是<strong>STDERR_FILENO</strong></li>
</ul>
</li>
<li><p><strong>Linux文件IO函数:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span><span class="comment">//打开一个文件，成功返回文件的描述符，失败返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">mode_t</span> mode)</span><span class="comment">//产生一个文件，成功返回新的文件描述符，错误会返回-1，并将错误代码给errno</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span><span class="comment">//关闭文件，释放文件占用资源，顺利关闭返回0，发生错误返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span><span class="comment">//将fd所致文件传送count个字节到buf中，文件读写位置会随着读取的字节移动，成功返回读取的字节，错误返回-1,存入errno中</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span><span class="comment">//将buf所指count个字节写到fd所指文件中，成功返回写入字节，错误返回-1，存入errno中;**最大数据范围**8192</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...)</span><span class="comment">//(设备驱动程序中对设备的I/O通道进行管理):主要完成对设备的控制，如串口传输波特率，这种会通过内核直接到底层驱动</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//将修改过的块缓冲区排入写队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;<span class="comment">//等待磁盘操作结束才返回，确保修改过的块立即写到磁盘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;<span class="comment">//类似fsync，但只影响数据部分，不影响属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Example:</strong> IO读写代码示范</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((num = read(STDIN_FILENO, buf, <span class="number">10</span>))== <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read error&quot;</span>);error(<span class="number">-1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//将键盘输入又输出到屏幕中</span></span><br><span class="line">    write(STDOUT_FIENO,buf,num)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3-Linux标准I-O"><a href="#3-3-Linux标准I-O" class="headerlink" title="3.3 Linux标准I/O"></a>3.3 Linux标准I/O</h3><h4 id="3-3-1-基本概念"><a href="#3-3-1-基本概念" class="headerlink" title="3.3.1 基本概念"></a>3.3.1 基本概念</h4><ul>
<li><p><strong>基本定义:</strong> 标准I/O库对底层I/O系统调用进行了封装，原型在文件stdio.h中定义，是<strong>ANSI C</strong>规范的一部分，<strong>分离应用程序空间和实际的物理设备</strong>，减少了直接读盘次数，提高性能</p>
</li>
<li><p><strong>缓冲:</strong> 全缓冲与行缓冲，标准错误不带缓冲</p>
<ul>
<li><strong>全缓冲:</strong> 除了指向终端设备的文件其他一般是全缓冲，也就是如果printf到文件的话,需要执行IO清理函数才会输出</li>
<li><strong>行缓冲:</strong> 命令行就是行缓冲，也就是遇到换行符就会执行IO清理函数直接输出，不会等到exit调用才输出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;<span class="comment">//长度为BUFSIZE的用户缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;<span class="comment">//mode指定缓冲类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缓冲实例:</strong> 需要注意是否执行IO flush操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以prinf为例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main is done /n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果将其输出到文件，则是全缓冲，无输出</span></span><br><span class="line"><span class="comment">//如果将其输出到命令行，则是行缓冲，会有语句出来</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-3-2-标准I-O函数"><a href="#3-3-2-标准I-O函数" class="headerlink" title="3.3.2 标准I/O函数"></a>3.3.2 标准I/O函数</h4><ul>
<li><p><strong>文件打开标准IO函数:</strong> 注意打开与关闭的缓冲机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;<span class="comment">//打开的是文件描述符，并使一个标准I/O流与该描述符相结合;常用于由创建管道及网络通信道函数返回的描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span><span class="comment">//执行这个的时候会执行IO冲洗的操作</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">限制</th>
<th style="text-align:center">r</th>
<th style="text-align:center">w</th>
<th style="text-align:center">a+</th>
<th style="text-align:center">r+</th>
<th style="text-align:center">w+</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件必须存在</td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">删除文件以前内容</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">流可以读</td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">流可以写</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">流只在尾端处写</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>读标准IO函数:</strong>  将unsigned char转换为int，在返回时再加上一个已出错或已到达文件尾端的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;<span class="comment">//用于一次读取一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;<span class="comment">//用于一次读取一个字符,不能被实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//用于一次读取一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;<span class="comment">//将从流中读取的数据重新押送回流中，顺序相反</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>每次一行IO:</strong> 每次输入一行 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;<span class="comment">//读取buf中n-1个直到出现换行符，缓冲区以null结尾</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;<span class="comment">//每次输出直到以null结尾的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;<span class="comment">//写到标准输出，添加换行符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-4-Linux文件定位"><a href="#3-4-Linux文件定位" class="headerlink" title="3.4 Linux文件定位"></a>3.4 Linux文件定位</h3><ul>
<li><p><strong>文件长度与文件空洞:</strong> 文件长度通常是一个数的整数倍，当设置的偏移量超过了文件尾端的时候就会产生很多<strong>空洞</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l file <span class="comment">//查看文件大小(会计算空洞)</span></span><br><span class="line">du -s file <span class="comment">//查看文件实际占用了多少块</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>lseek函数:</strong> 改变文件的当前偏移量,失败返回-1，成功返回移动后的文件偏移量，对fd进行offset偏移，再下次读写进行修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> origin)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pread函数:</strong> 在给定的偏移量读取一个文件描述符，即lseek和read的结合，解决同时调用lseek和read时内核同步问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> pos)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pwrite函数:</strong> 在给定的偏移量写入一个文件描述符，即lseek和write的结合，解决同时调用lseek和write时内核同步问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> pos)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-5-Linux文件共享"><a href="#3-5-Linux文件共享" class="headerlink" title="3.5 Linux文件共享"></a>3.5 Linux文件共享</h3><ul>
<li><p><strong>父子进程:</strong>  打开同一个文件表，读写操作基于当前位置</p>
</li>
<li><p><strong>不同进程与相同进程:</strong> 打开不同的文件表，各自基于文件当前位置</p>
</li>
<li><p><strong>fcntl函数:</strong> 可以改变已经打开文件的属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/*int arg*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>dup和dup2函数:</strong> 复制一个文件的描述符，dup函数返回复制的描述符，dup2把复制的描述符给targetfd;可以用来实现<strong>同一进程共享一个文件表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br><span class="line">int dup2(int oldfd, int targetfd);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程的概念:</strong> 轻量级进程，相对独立、可独立调度和指派的执行单元</p>
<ul>
<li><p><strong>线程的创建:</strong> API可以通过clone()调用接口调用do_fork()</p>
</li>
<li><p><strong>多线程共享:</strong> 文件对象结构都是共享的，所以当线程对文件进行操作时，会影响到其他线程</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-6-Linux目录操作"><a href="#3-6-Linux目录操作" class="headerlink" title="3.6 Linux目录操作"></a>3.6 Linux目录操作</h3><ul>
<li><p><strong>文件类型:</strong> 普通文件，目录文件，字符特殊文件，块设备文件，管道或FIFO, 符号链接，Socket套接字</p>
</li>
<li><p><strong>ls-l功能分析:</strong> 对ls的命令操作分析如下:</p>
<p><img src="/2020/08/20/Software/system/operating-system/Linux_ls.png" alt="Linux_ls"></p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标识</th>
<th style="text-align:center">文件类型</th>
<th style="text-align:center">标示</th>
<th style="text-align:center">文件访问权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">普通文件</td>
<td style="text-align:center">r</td>
<td style="text-align:center">读权限</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">目录文件</td>
<td style="text-align:center">w</td>
<td style="text-align:center">写权限</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">字符设备文件</td>
<td style="text-align:center">x</td>
<td style="text-align:center">执行权限</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">管道或FIFO</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">符号链接</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">套接字</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">块设备文件</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>目录操作函数集锦</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 获取当前工作目录</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_current_dir_name</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取当前工作路径</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">// 打开目录,返回目录流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dir)</span></span>; <span class="comment">// 关闭目录</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>; <span class="comment">//读取目录流</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//创建目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; <span class="comment">//删除目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>; <span class="comment">//改变当前工作目录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dir)</span></span>; <span class="comment">//设置目录读取位置(原来开头位置)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dir, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">//读取开头+offset的目录位置</span></span><br><span class="line">off_t telldir(DIR *dir)；//获取目录读取位置</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scandir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir, struct dirent **namelist, nt(*select)(<span class="keyword">const</span> struct dirent*),nt(*compar)(<span class="keyword">const</span> struct dirent**,<span class="keyword">const</span> struct dirent**))</span></span>;<span class="comment">//读取特定目录数据</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-7-Linux文件属性管理"><a href="#3-7-Linux文件属性管理" class="headerlink" title="3.7 Linux文件属性管理"></a>3.7 Linux文件属性管理</h3><ul>
<li><p><strong>文件inode:</strong> 文件中包含了文件类型、文件访问权限位、文件长度、指向文件数据块的指针等</p>
</li>
<li><p><strong>读取文件属性:</strong> stat中包含了st_mode,其中包含了<strong>文件访问权限，文件类型</strong>，其调用函数如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,struct stat *buf)</span></span>;<span class="comment">//返回指定文件属性，对于符号链接文件，返回引用的文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;<span class="comment">//返回制定文件属性，对于符号链接文件，返回符号链接文件属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, structe stat *buf)</span></span>;<span class="comment">//与上述一致，传入参数编程fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> oathname,struct stat *<span class="keyword">restrict</span> buf,<span class="keyword">int</span> flag)</span><span class="comment">//相对于当前打开目录的路径名返回文件统计信息，flag设定返回的实际文件信息</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件长度:</strong> </p>
<ul>
<li><strong>普通文件:</strong> 该文件的长度</li>
<li><strong>目录:</strong> 16或512的整倍数</li>
<li><strong>符号链接:</strong> 链接的文件名中的实际字节数</li>
</ul>
</li>
<li><p><strong>创建和删除文件硬链接:</strong> 任何一个文件可以有多个目录项指向其i节点，以下创建和分离的都是硬链接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;<span class="comment">//创建指向现有文件的新目录项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;<span class="comment">//efd与existingpath共同决定路径，flag是链接文件设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; <span class="comment">//删除目录项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span></span>; <span class="comment">//删除目录项,flag是链接文件设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span>)</span></span>;<span class="comment">//读取符号文件链接的文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; <span class="comment">//删除整个目录，参数为普通文件时等于unlink(库函数)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建和读取符号链接:</strong> 创建或读取符号链接文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; <span class="comment">//创建一个指向actualpath的新目录项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; <span class="comment">//路径可以多种选择</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize)</span></span>;<span class="comment">//读取文件链接本身的文件</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize)</span></span>;<span class="comment">//路径多选</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更名文件和目录:</strong>  对文件或者目录进行重命名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;<span class="comment">//更名文件或目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> cahr *pathname, <span class="keyword">const</span> struct utimbuf *times)</span></span>;<span class="comment">//设置存取和修改文件的时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件属性函数:</strong> 文件截断，在文件尾端处截去一些数据以缩短文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">off_t</span> length)</span><span class="comment">//改变文件长度;掉电会消失，因此可以在末尾进行补0操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">//根据用户ID获取用户属性</span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">//根据组ID获取组属性</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-8-Linux文件权限管理"><a href="#3-8-Linux文件权限管理" class="headerlink" title="3.8 Linux文件权限管理"></a>3.8 Linux文件权限管理</h3><ul>
<li><p><strong>检查文件权限:</strong> 进程访问文件时，内核会对<strong>文件的所有者</strong>，<strong>文件的所有者所在组</strong>，<strong>进程的有效用户ID</strong>，<strong>进程的有效组ID</strong>，<strong>进程的附加组</strong>进行检查</p>
</li>
<li><p><strong>基本概念:</strong> access通过判断<strong>实际用户ID</strong>和<strong>实际用户组ID</strong>是否是执行文件权限的可用ID，一般在执行进程的时候，需要对权限进行检查。新文件的创建的权限ID取决于设置的ID位</p>
</li>
<li><p><strong>权限管理:</strong> 检查是否具有权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>; <span class="comment">//测试存取文件是否具有相应权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;<span class="comment">//flag可以指定测试的用户</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程创建屏蔽字:</strong> 为进程设置文件模式创建屏蔽字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> cmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更改文件的访问权限:</strong> 修改文件的权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//改变指定文件的权限位,有效用户ID必须是文件的所有者ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//对已经打开的文件进行操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;<span class="comment">//flag决定符号链接</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更改文件所有者:</strong> 更改文件的用户ID和组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; <span class="comment">//更改文件的用户ID和组ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;<span class="comment">//指向打开文件的所有者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> cahr *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; <span class="comment">//更改符号链接本身的所有者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flag)</span></span>;<span class="comment">//更改符号链接本身的所有者</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-Linux进程基本概念"><a href="#4-Linux进程基本概念" class="headerlink" title="4. Linux进程基本概念"></a>4. Linux进程基本概念</h2><h3 id="4-1-进程在内核中的组织"><a href="#4-1-进程在内核中的组织" class="headerlink" title="4.1 进程在内核中的组织"></a>4.1 进程在内核中的组织</h3><ul>
<li><p><strong>基本概念:</strong> 程序是存放可执行代码等信息的文件，存放在磁盘等介质上，程序分配内存后就变成进程，程序是静态概念，进程是动态概念</p>
</li>
<li><p><strong>main函数:</strong> argc表示命令行参数的数目，argv是指向参数的各个指针所构成的数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行流程图:</strong> 进程状态以及初始化进程的内容如下</p>
<p><img src="/2020/08/20/Software/system/operating-system/process_flow_chart.png" alt="process_flow_chart"></p>
</li>
<li><p><strong>进程控制块(PCB):</strong>  进程ID/用户ID/进程状态/调度信息/文件管理/虚拟内存管理/信号(进程间通信机制)/时间和定时器</p>
</li>
</ul>
<h3 id="4-2-进程属性"><a href="#4-2-进程属性" class="headerlink" title="4.2 进程属性"></a>4.2 进程属性</h3><ul>
<li><p><strong>进程ID:</strong> 返回当前进程的ID，失败返回-1(错误存在errorno中)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回调用进程的进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回调用进程的父进程ID</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用户和组的概念:</strong> Linux是一个多用户多任务的操作系统，要使用系统资源，则需要向系统管理员申请一个用户；申请相同权限的用户多了，系统则需要利用组将用户管理起来。</p>
<ul>
<li><strong>超级用户:</strong> 文件的所有者</li>
<li><strong>普通用户:</strong> 对授予的权限进行目录访问，具有登陆系统的权限，如www用户，ftp用户等</li>
<li><strong>虚拟用户:</strong> 为了方便系统管理而设立的用户，如默认的bin用户等</li>
<li><strong>相关配置文件:</strong> <ul>
<li><strong>密码存放:</strong> 密码存放在/etc/passwd文件</li>
<li><strong>密码安全管理:</strong> 管理员创建了从passwd文件复制的/etc/shadow文件使得各个用户密码分离，每个用户只能访问自己的</li>
<li><strong>名字权限管理:</strong> 都存放在/etc/group</li>
<li><strong>用户创建:</strong> 默认创建文件/etc/default/useradd文件，用户默认住目录在home下，使用的shell是/bin/bash，<strong>bash</strong>相当于一种程序，所以也就是为什么我们访问服务器的时候，进入以后就是命令行，因为bash默认开启了</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>真实用户ID和真实用户组ID:</strong> 执行命令的用户，真实用户组为真实用户所在的组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回调用进程的实际用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回调用进程的实际组ID</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程有效用户和有效用户组:</strong> 默认的话与真实用户ID相同，但是文件所有者root如果设置了setuid位或setgid位则发生变化，比如passwd本来是只有root可以修改，如果设置了setuid给真实用户的话，则允许用户通过passwd文件修改密码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回调用进程的有效用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//返回调用进程的有效组ID</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-3-进程生命周期"><a href="#4-3-进程生命周期" class="headerlink" title="4.3 进程生命周期"></a>4.3 进程生命周期</h3><ul>
<li><p><strong>进程终止:</strong> 从C语言程序main进入到函数退出的流程</p>
<p><img src="/2020/08/20/Software/system/operating-system/process_exit.png" alt="process_exit"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//在main函数中,return与exit产生相同效果，exit时POSIX API函数，return是C语言关键字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;<span class="comment">//也就是return,这个执行后，执行终止进程的函数，执行文件I/O操作的清理工作，返回内核</span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);<span class="comment">//直接返回内核</span></span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);<span class="comment">//立即返回内核</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">* **注册终止处理函数:** exit函数调用时调用</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;c</span><br><span class="line">  #include&lt;stdlib.h&gt;</span><br><span class="line">  int atexit(void (*func)(void));&#x2F;&#x2F;调用exit的时候可以在这里面找终止进程函数，调用的时候与注册时候的顺序相反</span><br><span class="line">  int on_exit(void (*func)(int, void*), void *arg);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>存储空间分配:</strong>  存储空间动态分配，系统底层调用sbrk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">//分配指定字节数的存储区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;<span class="comment">//为指定数量，指定长度的对象分配存储空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;<span class="comment">//增加或减少以前分配区的长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数跳转:</strong> 如果递归深层的话，跳转只能一层一层跳，这样就很慢，所以C语言提供了setjmp跟longjmp两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>; <span class="comment">//设置返回的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span><span class="comment">//通过这个函数来跳转回去，恢复栈状态的所有信息</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-4-进程环境"><a href="#4-4-进程环境" class="headerlink" title="4.4 进程环境"></a>4.4 进程环境</h3><ul>
<li><p><strong>进程内存空间布局:</strong> 其内核空间与用户空间布局如图所示，</p>
<p><img src="/2020/08/20/Software/system/operating-system/memory_space.png" alt="memory_space"></p>
</li>
<li><p><strong>C语言内存空间布局:</strong> 即上图的用户空间</p>
<ul>
<li><strong>正文:</strong> 存放CPU的代码部分</li>
<li><strong>初始化的数据:</strong> 包含了程序中须明确赋初值的变量</li>
<li><strong>未初始化的数据:</strong> 将此段中的数据初始化为0</li>
<li><strong>栈:</strong> <strong>自动变量以及每次函数调用时所需保存的信息</strong>都存放在此段，递归调用也是在这个里面储存</li>
<li><strong>堆:</strong> 用于动态存储分配,比方说malloc</li>
<li><strong>命令行参数和环境变量:</strong> 用于支撑函数调用存放参数、局部变量等</li>
</ul>
</li>
<li><p><strong>环境变量:</strong> 每个进程都会有自己的环境变量表，通过<strong>全局的环境指针(environ)可以直接访问环境变量表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; <span class="comment">//用于获取环境变量值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>; <span class="comment">//将环境变量字符串放入环境变量表中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">int</span> rewrite)</span></span>;<span class="comment">//将制定环境变量的值设置为参数指定值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;<span class="comment">//删除指定的环境变量字符串</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-5-创建进程"><a href="#4-5-创建进程" class="headerlink" title="4.5 创建进程"></a>4.5 创建进程</h3><ul>
<li><p><strong>进程标识:</strong> ID0是调度进程，ID1是init进程，ID2是页守护进程</p>
<ul>
<li><strong>进程0—&gt;进程1(init进程):</strong> 进程0(PID=0)是由内核创建，其他所有进程都是由父进程调用fork函数所创建的，进程0再创建</li>
<li><strong>进程1—&gt;all进程:</strong> 进程1是系统中其他所有进程的共同祖先</li>
</ul>
</li>
<li><p><strong>创建子进程:</strong>  在子进程中返回值为0，在父进程中返回值为子进程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>fork函数工作流程:</strong></p>
<ul>
<li><p><strong>子进程是父进程的副本:</strong> 子进程<strong>复制</strong>父进程的PCB、数据空间，他们之间共享正文段(代码)(只读)，两个进程之间数据段、堆和栈遭到修改时，采用写时复制机制(Copy-On-Write)</p>
<p><img src="/2020/08/20/Software/system/operating-system/process.png" alt="fork_process"></p>
</li>
<li><p><strong>子进程与父进程继续执行fork函数调用之后的代码:</strong> 利用wait函数来等待子进程完成任务</p>
</li>
</ul>
</li>
<li><p><strong>父子进程在子进程结束前结束:</strong> 子进程由init进程收养</p>
</li>
<li><p><strong>父子进程执行不同可执行文件:</strong> 调用exec</p>
</li>
<li><p><strong>fork函数使用例子:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid=fork();</span><br><span class="line">  <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error \n&quot;</span>)</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;in child process!!\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;the returned value is %d\n&quot;</span>, pid);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;in father process!!\n&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;My PID is %d\n&quot;</span>, getpid());</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 执行结果:</span></span><br><span class="line"><span class="comment">The returned value is 2547</span></span><br><span class="line"><span class="comment">In father process!!</span></span><br><span class="line"><span class="comment">My PID is 2546</span></span><br><span class="line"><span class="comment">The returned value is 0</span></span><br><span class="line"><span class="comment">In child process!!</span></span><br><span class="line"><span class="comment">My PID is 2547 */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-6-获知子进程运行状态改变"><a href="#4-6-获知子进程运行状态改变" class="headerlink" title="4.6 获知子进程运行状态改变"></a>4.6 获知子进程运行状态改变</h3><ul>
<li><p><strong>父进程结束，子进程还没退出:</strong> 若父进程在子进程退出前退出，则子进程的父进程将变为init进程，<strong>由init进程调用wait函数进行善后</strong></p>
</li>
<li><p><strong>子进程结束，父进程等待:</strong> 子进程结束，父进程用wait等待子进程返回，所以这样的话父进程就阻塞了，但如果父进程没有用wait等待子进程返回，则成为了<strong>僵尸进程</strong></p>
</li>
<li><p><strong>子进程结束，父进程不想等待:</strong> 采用<strong>fork两次</strong>的结果，fork一次之后子进程立即fork第二次，然后<strong>子进程立马结束，父进程得到子进程的结束，可以继续执行</strong>，孙子进程<strong>由于父进程结束，父进程变成了init进程，也可以继续执行</strong></p>
</li>
<li><p><strong>获知子进程状态信息改变:</strong> 进程状态改变时，内核向其父进程发送SIGCHLD信号(子进程终止，init进程保存了一定量的信息),用wait获取任意子进程状态改变信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statloc)</span></span>;<span class="comment">//获取子进程的进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">/* 内核将状态信息改变存入statloc指向的存储空间,其实也就是子进程的返回值存到statloc中,waitpid将得到特定子进程状态改变的信息*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-7-在进程中执行可执行文件"><a href="#4-7-在进程中执行可执行文件" class="headerlink" title="4.7 在进程中执行可执行文件"></a>4.7 在进程中执行可执行文件</h3><ul>
<li><p><strong>execl函数:</strong>  l表示每个命令参数都说明为一个单独的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int execl(const char *pathname, const char *arg0,...,NULL) pathname为程序路径, arg为参数,NULL((char*)0)结尾</span></span><br><span class="line">execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>((<span class="keyword">char</span>*)<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>execv函数和execve函数:</strong>  v表示命令行参数放在数组中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *argv[] =&#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>execle函数:</strong> e表示由函数调用者提供环境变量表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *envp[] = &#123;<span class="string">&quot;PATH=/tmp&quot;</span>, <span class="string">&quot;USER=shan&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execle(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>,envp)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>execlp函数和execvp, fexecve:</strong> p表示通过环境变量PATH来指定路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char*)0*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-Linux线程基本概念"><a href="#5-Linux线程基本概念" class="headerlink" title="5. Linux线程基本概念"></a>5. Linux线程基本概念</h2><h3 id="5-1-Linux线程控制"><a href="#5-1-Linux线程控制" class="headerlink" title="5.1 Linux线程控制"></a>5.1 Linux线程控制</h3><ul>
<li><p><strong>线程的基本概念:</strong> 线程是<strong>进程内的独立执行代码的实体和调度单元</strong>，一个进程内的所有线程共享进程的所有信息，没有显式创建线程则进程可以看成只有一个线程的进程</p>
<p><img src="/2020/08/20/Software/system/operating-system/processs_compare_thread.png" alt="processs_compare_thread"></p>
</li>
<li><p><strong>线程标识:</strong> 每个线程都会有自己的ID，只有在他所属的进程上下文中才有意义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程/线程控制操作对:</strong> </p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">控制操作</th>
<th style="text-align:center">进程操作API</th>
<th style="text-align:center">线程操作API</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">fork,vfork</td>
<td style="text-align:center">pthread_create</td>
</tr>
<tr>
<td style="text-align:center">终止</td>
<td style="text-align:center">exit</td>
<td style="text-align:center">pthread_exit</td>
</tr>
<tr>
<td style="text-align:center">等待/阻塞</td>
<td style="text-align:center">wait、waitpid</td>
<td style="text-align:center">pthread_join</td>
</tr>
<tr>
<td style="text-align:center">读取ID</td>
<td style="text-align:center">getpid</td>
<td style="text-align:center">pthread_self</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>获取线程ID:</strong> 调用线程获取自己的线程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">()</span></span>; <span class="comment">//返回调用线程的线程ID</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程的创建:</strong> 创建一个线程，线程创建并不能保证哪个线程会先执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *<span class="keyword">restrict</span> arg)</span></span>; <span class="comment">//tidp代表指向线程的指针，attr代表线程的属性，一般NULL表示默认，start_rtn启动历程函数指针,arg表示启动历程函数传递信息的参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程的终止:</strong> 三种线程的退出方式，在用join的时候需要注意，<strong>当线程退出时，其栈的数据也跟着退出了，所以要用这个数据必须是全局的或者用malloc分配的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;<span class="comment">//自身退出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;<span class="comment">//取消同一进程中的其他线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;<span class="comment">//父线程被阻塞，直到指定的子线程终止</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程清理处理程序:</strong> 处理程序记录在栈中，执行顺序与注册时相反</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*rtn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;<span class="comment">//只用在pthread_exit或响应取消请求或非零调用pthread_cleanup_pop时，才会执行清理函数rtn</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;<span class="comment">//execute被设置为0，则清理函数不再调用，</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程的死锁:</strong> 当一个线程占用A，然后需要B，另一个线程占用B，然后需要A，就会造成死锁。</p>
<ul>
<li><strong>解决办法:</strong> 死锁可以通过控制两个线程的锁的顺序</li>
</ul>
</li>
</ul>
<h3 id="5-2-线程同步机制—互斥量"><a href="#5-2-线程同步机制—互斥量" class="headerlink" title="5.2 线程同步机制—互斥量"></a>5.2 线程同步机制—互斥量</h3><ul>
<li><p><strong>线程的数据共享:</strong> 线程对于全局变量的访问，先读入寄存器，再对寄存器的值进行运算，再将寄存器的值写回内存单元。</p>
<p><img src="/2020/08/20/Software/system/operating-system/pthread_share.png" alt="pthread_share"></p>
</li>
<li><p><strong>临界资源:</strong> 在一段时间内只允许一个任务访问的资源，需要采用互斥的方式进行资源共享，共享变量属于临界资源，访问临界资源的代码被称为临界区</p>
</li>
<li><p><strong>互斥量:</strong> 确保同一时间内只有一个线程访问临界资源，<strong>互斥量本身是一把锁</strong>，互斥量加锁以后，<strong>其他企图对互斥量加锁的线程都会被阻塞，</strong>互斥量的操作如下:</p>
<ul>
<li><p><strong>定义互斥量变量—&gt;初始化互斥量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mlock = PTHREAD_MUTEX_INITIALIZER<span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span> pthread_mutex_init(<span class="keyword">pthread_mutex_t</span> *mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr);<span class="comment">//动态初始化，mutex指向互斥量的指针，attr设置互斥量的属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问临界资源前对互斥量加锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex)；//若未加锁，则对互斥量加锁；若未加锁，则返回错误</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问临界资源后对互斥量解锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>销毁互斥量变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; <span class="comment">//互斥量销毁</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-线程同步机制—条件变量"><a href="#5-3-线程同步机制—条件变量" class="headerlink" title="5.3 线程同步机制—条件变量"></a>5.3 线程同步机制—条件变量</h3><ul>
<li><p><strong>任务同步—相互合作问题:</strong> 两个或多个任务为了合作完成同一个工作，在执行速度或某个确定的是时序点上必须相互协调</p>
</li>
<li><p><strong>条件变量:</strong> Linux提供了条件变量机制，条件变量与互斥量一起使用时，允许线程以互斥的方式阻塞等待特定条件的发生(同步)</p>
</li>
<li><p><strong>条件变量与互斥量同步过程:</strong> </p>
<ul>
<li>消费者拿到互斥锁，进入临界区，<strong>利用while判断当前变量是否满足执行条件</strong>，进入条件变量等待pthread_cond_wait函数</li>
<li>条件变量等待会释放互斥锁，让生产者<strong>拿到互斥锁</strong>，<strong>生产者生产资源，然后释放互斥锁</strong>，<strong>通知消费者来拿条件变量</strong>pthread_cond_signal()</li>
<li>消费者再次拿到互斥锁，执行程序</li>
</ul>
</li>
<li><p><strong>条件变量相关函数:</strong></p>
<ul>
<li><p><strong>定义条件变量</strong>(pthread_cond_t类型),定义互斥量变量，初始化条件变量，初始化互斥量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<span class="comment">//静态初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;<span class="comment">//动态初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>触发条件线程x</strong>:互斥量加锁-&gt;XX操作-&gt;触发条件变量-&gt;互斥量解锁</p>
</li>
<li><p><strong>等待条件线程y</strong>, 将调用线程进入阻塞状态: 互斥量加锁-&gt;等待条件变量-&gt;XX操作-&gt;互斥量解锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>销毁条件变量</strong>，销毁互斥量变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_destroy(<span class="keyword">pthread_cond_t</span> *cond);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="5-4-线程同步机制—读写锁"><a href="#5-4-线程同步机制—读写锁" class="headerlink" title="5.4 线程同步机制—读写锁"></a>5.4 线程同步机制—读写锁</h3><ul>
<li><p><strong>读者-写者问题:</strong> 对临界资源的访问更多的是读操作，因此希望有一下关系:</p>
<ul>
<li>读操作-写操作互斥</li>
<li>写操作-写操作互斥</li>
<li>读操作-读操作不互斥</li>
</ul>
</li>
<li><p><strong>读写锁通信机制: </strong> 保证互斥，提供控制粒度更细的读写锁机制</p>
</li>
<li><p><strong>读写锁操作:</strong></p>
<ul>
<li>定义读写锁变量</li>
<li>初始化读写锁变量</li>
<li>访问临界资源(读操作或写操作)前对读写锁加锁</li>
<li>访问临界资源后对读写锁解锁</li>
<li>销毁读写锁变量</li>
</ul>
</li>
<li><p><strong>读写锁的初始化和销毁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock; <span class="comment">//定义读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(..)</span></span>; <span class="comment">// 初始化读写锁变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(..)</span></span>; <span class="comment">//销毁读写锁变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(..)</span></span>; <span class="comment">//阻塞加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(..)</span></span>; <span class="comment">// 非阻塞加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlocke</span><span class="params">(..)</span></span>; <span class="comment">//限时等待加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(..)</span></span>; <span class="comment">//阻塞加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(..)</span></span>; <span class="comment">// 非阻塞加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlocke</span><span class="params">(..)</span></span>; <span class="comment">//限时等待加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(..)</span></span>;<span class="comment">//读写锁解锁，为代码最近的加锁操作解锁</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-Linux进程间通信机制概述"><a href="#6-Linux进程间通信机制概述" class="headerlink" title="6. Linux进程间通信机制概述"></a>6. Linux进程间通信机制概述</h2><p><img src="/2020/08/20/Software/system/operating-system/process_communication.png" alt="process_communication"></p>
<h3 id="6-1-Linux通信机制—管道"><a href="#6-1-Linux通信机制—管道" class="headerlink" title="6.1 Linux通信机制—管道"></a>6.1 Linux通信机制—管道</h3><ul>
<li><p><strong>管道(Pipes):</strong> 最古老、最简单的UNIX进程间通信机制, 一种特殊的文件</p>
<p><img src="/2020/08/20/Software/system/operating-system/pipe_communication.png" alt="pipe_communication"></p>
<ul>
<li><strong>半双工:</strong> 一个文件打开作为进程写，一个文件打开作为进程读</li>
<li>只能在<strong>父子进程</strong>之间使用</li>
</ul>
</li>
<li><p>管道系统调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fildes[<span class="number">2</span>])</span></span>; <span class="comment">//创建管道;filedes[0]管道读操作,filedes[1]管道写操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; <span class="comment">//创建FIFO</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命名管道(FIFO):</strong> 可以通过文件I/O对其进行操作</p>
<ul>
<li>在UNIX用得最典型的就是 | 指令，使得各个程序指令可以并行</li>
<li><strong>管道特点:</strong><ul>
<li>相比于每个进程单独进行执行的话，省CPU时间，省内存，因为其中的话采用的是阻塞机制以及缓存机制</li>
</ul>
</li>
<li>比较容易受其他进程影响，一个出错就不能用了</li>
</ul>
</li>
<li><p><strong>XSI IPC(Interprocess Communication)机制:</strong></p>
<ul>
<li><strong>信号量集:</strong> 用于实现进程之间的同步与互斥</li>
<li><strong>共享内存:</strong> 用于在进程之间高效地共享数据</li>
<li><strong>消息队列:</strong> 进程之间传递数据的一种简单方法</li>
</ul>
</li>
<li><p><strong>IPC对象的key值和ID:</strong></p>
<ul>
<li>IPC机制的ID值为动态分配，key值与IPC对象一一对应</li>
<li>进程申请IPC对象时，由于key值不能重复，所以首次使用该key值会真正创建，而后续则直接找到该对象然后打开使用</li>
</ul>
</li>
</ul>
<h3 id="6-2-进程通信机制—消息队列"><a href="#6-2-进程通信机制—消息队列" class="headerlink" title="6.2 进程通信机制—消息队列"></a>6.2 进程通信机制—消息队列</h3><p><img src="/2020/08/20/Software/system/operating-system/message_queue.png" alt="message_queue"></p>
<ul>
<li><p><strong>消息队列概述:</strong></p>
<ul>
<li>进程传递数据的一种方法，每个消息看成一个记录，消息队列就是消息的链表</li>
<li>具有写权限的可以添加新消息，具有读权限的可以读走消息</li>
<li>克服管道机制的实时性差等缺点</li>
</ul>
</li>
<li><p><strong>消息队列操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">// 打开或创建消息队列对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//从消息队列接受消息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf *msgp, <span class="keyword">int</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>; <span class="comment">//向消息队列发送消息</span></span><br><span class="line">msgctl(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf); <span class="comment">//消息队列控制操作</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-3-进程通信机制—信号量集"><a href="#6-3-进程通信机制—信号量集" class="headerlink" title="6.3 进程通信机制—信号量集"></a>6.3 进程通信机制—信号量集</h3><ul>
<li><p><strong>基本概念:</strong> 信号量是软件中断，而硬件中断是原子事件，所有的函数要开始都源自于信号量Signal</p>
<p><img src="/2020/08/20/Software/system/operating-system/Signal.png" alt="Signal"></p>
</li>
<li><p><strong>信号量函数:</strong> 处理异步事件的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);<span class="comment">//获取signo信号，执行信号触发function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;<span class="comment">//调用alarm计秒数，秒数过后，执行sig_alarm函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>信号集函数:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemeptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//清除其中所有信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//初始化由set指向的信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;<span class="comment">//将一个信号添加到已有的信号集中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;<span class="comment">//从信号集删除一个信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;<span class="comment">//测试一个指定的位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>;<span class="comment">//信号屏蔽字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//各信号阻塞不能传送</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *<span class="keyword">restrict</span> act, struct sigaction *resrict oact)</span></span>;<span class="comment">//检查或修改与指定信号相关联的处理动作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;ß</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作系统中任务资源共享情况:</strong></p>
<ul>
<li><strong>临界资源:</strong> 在一段时间内只允许一个任务访问的资源</li>
<li>共享资源: 允许多个任务同时访问同一种资源</li>
</ul>
</li>
<li><p><strong>信号量:</strong> 操作系统提供的管理资源共享的有效手段，作为核心代码执行，其地位高于任务，任务调度不能终止其运行</p>
<ul>
<li><strong>互斥信号量:</strong> 任务之间互斥访问临界资源</li>
<li><strong>计数信号量:</strong> 任务之间竞争访问共享资源</li>
<li><strong>二值信号量:</strong> 任务之间的同步机制</li>
</ul>
</li>
<li><p><strong>信号量操作:</strong> 每一个信号量都有自己一个名字</p>
</li>
<li><p><strong>信号量的实现:</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* s.count:实现资源计数，初始化为可用的共享资源总数,负数表示等待的资源计数</span></span><br><span class="line"><span class="comment">s.queue: 任务阻塞队列 */</span></span><br><span class="line"><span class="comment">/* wait(s) P操作 */</span></span><br><span class="line">--s.count; <span class="comment">// 表示申请一个资源</span></span><br><span class="line"><span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)<span class="comment">//表示没有空闲资源;</span></span><br><span class="line">&#123; </span><br><span class="line">  调用进程进入阻塞队列s.<span class="built_in">queue</span>;</span><br><span class="line">	阻塞调用进程;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* signal(s) V操作 */</span></span><br><span class="line">++s.count；<span class="comment">//表示释放一个资源;</span></span><br><span class="line"><span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>) <span class="comment">//表示有进程处于阻塞状态;</span></span><br><span class="line">&#123;</span><br><span class="line">  从等待队列s.<span class="built_in">queue</span>中取出一个进程P;</span><br><span class="line">  进程P进入就绪队列;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XSI IPC 信号量集操作:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>; <span class="comment">//创建或打开信号量集对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span>; <span class="comment">//信号量集操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, <span class="keyword">union</span> semun arg)</span></span>; <span class="comment">//信号量集控制</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-4-进程通信机制—共享内存"><a href="#6-4-进程通信机制—共享内存" class="headerlink" title="6.4 进程通信机制—共享内存"></a>6.4 进程通信机制—共享内存</h3><ul>
<li><p><strong>基本概念:</strong> 共享内存是内核为进程间通信创建的特殊内存段，不同进程可以将同一段共享内存连接到自己的地址空间，其位置位于栈之下，堆之上，在栈与堆之间</p>
<ul>
<li>最快的进程间通信方式</li>
</ul>
</li>
<li><p>本身不具有互斥访问机制</p>
</li>
<li><p><strong>共享内存的操作:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> size, <span class="keyword">int</span> flag)</span></span>; <span class="comment">//打开或创建共享内存对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;<span class="comment">//将共享内存连接到进程空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; <span class="comment">//断开进程空间和共享内存的连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>; <span class="comment">// 共享内存控制操作</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-5-进程间网络通信"><a href="#6-5-进程间网络通信" class="headerlink" title="6.5 进程间网络通信"></a>6.5 进程间网络通信</h3><ul>
<li><strong>Server:</strong> Socket() —&gt; bind() —&gt; listen()—&gt; accept()(阻塞等待连接) —&gt;read()—&gt;write() —&gt;close()</li>
<li><strong>Client:</strong> socket() —&gt; connect() —&gt; write()—&gt;read() —&gt;close()</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Ball
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/" title="Linux操作系统详解">http://jiaqiuzhou.github.io/2020/08/20/Software/system/operating-system/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Software-System/" rel="tag"># Software-System</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/06/Knowledge/AcademicPapers/Paperwriting/write-review/" rel="prev" title="write_review_response">
      <i class="fa fa-chevron-left"></i> write_review_response
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/25/Knowledge/DeepLearning/Task/RecommendedSystem/" rel="next" title="RecommendedSystem">
      RecommendedSystem <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Computer"><span class="nav-text">1. Computer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-What-is-a-computer"><span class="nav-text">1.1 What is a computer?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-What-is-a-computer-program"><span class="nav-text">1.2 What is a computer program?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2. 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-text">2.1 发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B4%E4%BD%93%E6%80%9D%E6%83%B3"><span class="nav-text">2.2 linux系统的整体思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Everything-is-a-process%E2%80%94if-it%E2%80%99s-not-a-process-it%E2%80%99s-a-file"><span class="nav-text">2.2.1 Everything is a process—if it’s not a process, it’s a file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-One-tool-to-do-one-task"><span class="nav-text">2.2.2 One tool to do one task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-Three-standard-I-O-channels"><span class="nav-text">2.2.3 Three standard I&#x2F;O channels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-Combine-tools-seamlessly"><span class="nav-text">2.2.4 Combine tools seamlessly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-Plain-text-preferred"><span class="nav-text">2.2.5 Plain text preferred</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-CLI-not-GUI"><span class="nav-text">2.2.6 CLI, not GUI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-7-Modular-desigend-to-be-repurposed-by-others"><span class="nav-text">2.2.7 Modular,desigend to be repurposed by others</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-8-Provide-mechanisms-not-policies"><span class="nav-text">2.2.8 Provide mechanisms, not policies</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-text">2.3 系统架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%86%85%E6%A0%B8%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">2.4 内核的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.5 操作系统用户接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">2.6 系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E5%B8%B8%E7%94%A8UNIX-Linux%E5%91%BD%E4%BB%A4%E2%80%94shell%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.7 常用UNIX&#x2F;Linux命令—shell应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="nav-text">2.7.1 文件目录类命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="nav-text">2.7.2 进程控制类命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-%E7%94%A8%E6%88%B7%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="nav-text">2.7.3 用户及权限管理类命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="nav-text">2.8 程序编译调试方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2.8.1 执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-2-%E7%BC%96%E8%AF%91%E5%99%A8GCC-GNU-Compiler-Collection"><span class="nav-text">2.8.2 编译器GCC(GNU Compiler Collection)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-3-gdb%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-text">2.8.3 gdb程序调试工具</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-main-%E5%87%BD%E6%95%B0"><span class="nav-text">2.9 main 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-UNIX-Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">3. UNIX&#x2F;Linux文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 文件系统基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84IO%E6%93%8D%E4%BD%9C"><span class="nav-text">3.2 文件系统的IO操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Linux%E6%A0%87%E5%87%86I-O"><span class="nav-text">3.3 Linux标准I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.3.1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E6%A0%87%E5%87%86I-O%E5%87%BD%E6%95%B0"><span class="nav-text">3.3.2 标准I&#x2F;O函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Linux%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="nav-text">3.4 Linux文件定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-text">3.5 Linux文件共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Linux%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="nav-text">3.6 Linux目录操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86"><span class="nav-text">3.7 Linux文件属性管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-text">3.8 Linux文件权限管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">4. Linux进程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-text">4.1 进程在内核中的组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%BF%9B%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-text">4.2 进程属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%BF%9B%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">4.3 进程生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="nav-text">4.4 进程环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-text">4.5 创建进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E8%8E%B7%E7%9F%A5%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98"><span class="nav-text">4.6 获知子进程运行状态改变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">4.7 在进程中执行可执行文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Linux%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">5. Linux线程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Linux%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">5.1 Linux线程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-text">5.2 线程同步机制—互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">5.3 线程同步机制—条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-text">5.4 线程同步机制—读写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">6. Linux进程间通信机制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Linux%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E2%80%94%E7%AE%A1%E9%81%93"><span class="nav-text">6.1 Linux通信机制—管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">6.2 进程通信机制—消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86"><span class="nav-text">6.3 进程通信机制—信号量集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">6.4 进程通信机制—共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-text">6.5 进程间网络通信</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ball"
      src="/images/qiu.jpeg">
  <p class="site-author-name" itemprop="name">Ball</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JiaqiuZhou" title="GitHub → https://github.com/JiaqiuZhou" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhoujball@gmail.com" title="E-Mail → mailto:zhoujball@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ball</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">294k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:28</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'jv99mTz1aRnCcRkQKp6niCiF-gzGzoHsz',
      appKey     : 'SdAgfbnUruylQjpLNzwNV2fH',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
